@Tutorial(time: 5) {
    @Intro(title: "Facade как лицо модуля") {
        Иными словами это Input и Output модуля. 
        
        Начиная с Feature уровня модулей, рекомендуется оформлять Input/Output через Facade.
    }
    
    @Section(title: "Пример формирования Facade") {
        @ContentAndMedia {
            Если модуль создает какой-то продукт, то этот продукт должен быть доступен через Facade.
            
            Если модуль конфигурируется через какие-то параметры, то их тоже необходимо передавать через Facade. 
            
            Документация ко всем свойствам Facade обязательна.
        }
        
        @Steps {
            @Step {
                Рассмотрим пример фасада Network модуля.
                
                Основным продуктом Network являются сервисы.
                Плюсы наличия сервиса в фасаде в том, что так модулю уровнем выше не нужно думать о том какая фабрика и с какими параметрами создаст сервис. В статичном свойстве фасада мы уже вызвали правильный метод фабрики с правильными параметрами, упростив использование продуктов модуля.
                
                @Code(name: "NetworkModuleFacade.swift", file: Facade-01-01.swift)
            }
            
            @Step {
                Побочным продуктом Network можно назвать хранилища. 
                
                В таком случае следует ограничить уровень использования побочного продукта через протокол.
                В пример `DataCleanerCompatible` позволяет лишь очистить хранилище токена. 
                Не дает доступ до значений в токене. Не дает модифицировать токен.
                
                @Code(name: "NetworkModuleFacade.swift", file: Facade-01-02.swift, previousFile: Facade-01-01.swift)
            }
            
            @Step {
                В качестве Input можно передавать параметры конфигурации модуля.
                
                Это могут быть значения примитивных типов, готовые модели или протоколы
                
                @Code(name: "NetworkModuleFacade.swift", file: Facade-01-03.swift, previousFile: Facade-01-02.swift)
            }
            
            @Step {
                В случае с протоколами следует понимать, что в фасаде все функции статические. В конце концов установленный протокол будет записан в приватный Singleton внутри Network модуля.
                
                В нашем примере `ErrorCode` - это enum для парсинга кодов ошибок, со статичным свойством `localizer` для их локализации.
                
                @Code(name: "NetworkModuleFacade.swift", file: Facade-01-04.swift, previousFile: Facade-01-03.swift)
            }
        }
    }
}
